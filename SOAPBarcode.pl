#! usr/bin/perl -w

=head1 Desription

This program is attempt to assemble standard COI barcode region with two libraries, of which one is full length, another is shotgun.

=head1 Version

version 4.1
modified by Guanliang Meng: 1) add citation infor.

version 4.0 
modified by Guanliang Meng: 1) change usearch to vsearch;
          2) small bug fixed (partially) for reading a lib file (-lib option).

version 3.0 
modified: 1) protein express check can be skipped without setting -int and -pro n;
	  2) multiple primers with index ahead can be proccessed batching, however, if index
	     exists at only one end of primers (e.g. former), it should be tackled one by one
	     with parameter -len setted as 0;
	  3) PEAR was introduced as an option for shotgun reads overlap

Scripted by Jiangliang Lu && Shanlin LIU, any question can contact via liushanlin@genomics.cn

=head1 Usage

perl SOAPBarcode.pl <parameter>

		
---------------| the sequence information of two libs |-----------------

	-lib	lib file include information of all the raw data. Empty lines after
		each "[LIB]" for each library will lead to bugs!!!

-------------------------| denoise parameter|--------------------------

	-pri    the primer set include barcode sequnces ahead
	-len	the length of the barcode region, set as 0 when no index (0)
	-qac    the maximun B quality allowed for each seq(5)
	-abc    the minimum abandance of the uniq reads(2)
	-ucf	the similarity cutoff when clustering denoise(0.98)
	-int    the hydrophily interval of each site generated by Pro_C,
                formated in "site max min"
	-pro	protein coding gene expression check, (y|n)
	-mpr	the maximum number of mismatch check for primers including indexs ahead (1),
	-oop 	choose the overlap programs, 1 for COPE; 2 for PEAR (1),
	-osc	the similarity cutoff for shotgun reads overlaping for COPE (0.95)

-----------------------| assembly parameter |---------------------------

	-lmk	the maximum length of the kmer (115)
	-lsk	the minimum length of the kmer (95)
	-kin	the kmer interval (10)
	-clk	the lower frequency kmer cutoff (0.1)
	-clb	the lower support branch cutoff (0.1)
	-lms	the maximun extension length (660)
	-lss	the minimun extension length (450)
	-cpt	the CPU number allowed for each assembly task (8)

--------------------------| other parameter |---------------------------

	-ucs	the similarity cutoff of the OTU generation (0.98)
	-out	prefix of name of output file
	-help	print out this information

-----------------------------| Example |-------------------------------

commond:
perl SOAPBarcode.pl -lib test.lib -pri primer.fasta -int interval -pro y -out test -oop 2 -len 5 -mpr 0

=head1 Citation

    Liu S, Li Y, Lu J, Su X, Tang M, Zhang R, Zhou L, Zhou C, Yang Q, Ji Y, Yu DW. 
    SOAPBarcode: revealing arthropod biodiversity through assembly of Illumina
    shotgun sequences of PCR amplicons. Methods in Ecology and Evolution. 2013 Dec;4(12):1142-50.
    DOI: https://doi.org/10.1111/2041-210X.12120

=cut

use strict;
use Getopt::Long;
use FindBin qw($Bin $Script);
my ($Lib,$Ffq,$Bfq,$Fsfq,$Bsfq,$Primer,$Bcut,$Interval,$Out,$Help,$Len,$Minimum,$Mpr,$Pro,$Oop);
my ($Osc,$Lmk,$Lsk,$Kin,$Clk,$Clb,$Lms,$Lss,$Cpt,$Ucs,$Ucf,$Resume);
GetOptions(
	"lib:s"=>\$Lib,
	"pro:s"=>\$Pro,
	"pri:s"=>\$Primer,
	"qac:i"=>\$Bcut,
	"len:i"=>\$Len,
	"abc:i"=>\$Minimum,
	"int:s"=>\$Interval,
	"mpr:i"=>\$Mpr,
	"osc:i"=>\$Osc,
	"oop:i"=>\$Oop,
	"lmk:i"=>\$Lmk,
	"lsk:i"=>\$Lsk,
	"kin:i"=>\$Kin,
	"clk:i"=>\$Clk,
	"clb:i"=>\$Clb,
	"lms:i"=>\$Lms,
	"lss:i"=>\$Lss,
	"cpt:i"=>\$Cpt,
	"ucf:i"=>\$Ucf,
	"ucs:i"=>\$Ucs,
	"out:s"=>\$Out,
	"help"=>\$Help
);
# 	"resume"=>\$Resume,
$Bcut=5 if (!defined $Bcut);
$Len ||= 0;
$Minimum ||=2;
$Mpr=1 if (!defined $Mpr);
$Osc ||=0.95;
$Oop ||=1;
$Lmk ||=115;
$Lsk ||=91;
$Kin ||=10;
$Clk ||=0.1;
$Clb ||=0.1;
$Lms ||=660;
$Lss ||=450;
$Cpt ||=8;
$Ucs ||=0.98;
$Ucf ||=0.98;
die `pod2text $0` if ($Help || !defined $Lib || (defined $Interval && ($Pro eq "n"))|| !defined $Primer || !defined $Out);

open LIB, $Lib || die $!;
my (@in_si, @lrl, @fastq, $in_sif,$in_sis,$lrlf,$lrls);
while(<LIB>){
	chomp;
	next if(/^\s*$/); # mgl. fixed a bug if the lib file has emptt lines.
	my ($a, $b, $c, $d);
	if (/\[LIB\]/){
		chomp($a=<LIB>);
		chomp($b=<LIB>);
		chomp($c=<LIB>);
		chomp($d=<LIB>);
	
		die "wrong lib file, makesure the second line represents the insertsize" unless ($a=~s/insertsize=//);
		die "wrong lib file, makesure the second line represents the readlength" unless ($b=~s/readlength=//);
		die "wrong lib file, makesure the second line represents the fastq 1" unless ($c=~s/fq1=//);
		die "wrong lib file, makesure the second line represents the fastq 2" unless ($d=~s/fq2=//);
		push @in_si, $a;
		push @lrl, $b;
		push @fastq, $c;
		push @fastq, $d;
	}
}
die "wrong lib file, make sure the lib file include two libs with pair end reads" unless (@in_si==2 && @lrl==2 && @fastq==4);
if ($in_si[0] >= $in_si[1]){
	$in_sif=$in_si[0];
	$in_sis=$in_si[1];
	$lrlf=$lrl[0];
	$lrls=$lrl[1];
	$Ffq=$fastq[0];
	$Bfq=$fastq[1];
	$Fsfq=$fastq[2];
	$Bsfq=$fastq[3];
}else{
	$in_sif=$in_si[1];
	$in_sis=$in_si[0];
	$lrlf=$lrl[1];
	$lrls=$lrl[0];
	$Ffq=$fastq[2];
	$Bfq=$fastq[3];
	$Fsfq=$fastq[0];
	$Bsfq=$fastq[1];
}

########################get full length reads set###########################

my $f_out="$Out"."_f";
my @flist;
my $binpath= $Bin;
if ($Mpr == 0){
	`perl $binpath/bin/extract.perfect.pl -fq1 $Ffq -fq2 $Bfq -pri $Primer -out $f_out -len $Len -mis $Mpr -qua $Bcut >>log`;
}else{
	`perl $binpath/bin/extract.v1.pl -fq1 $Ffq -fq2 $Bfq -pri $Primer -out $f_out -len $Len -mis $Mpr -qua $Bcut >>log`;
}
print "fq1=$Ffq\nfq2=$Bfq\nreads has been assigned\n";
open FLI, "$f_out\_list" || die $!;
#open FEN, ">$fendlist" || die $!;
my $full_out_pct=(100-$Ucf*100);
while(<FLI>){
	chomp;
	my $dupout="$_".".dup";
	`$binpath/bin/vsearch --derep_fulllength $_ --output $dupout --sizeout --strand both --minuniquesize 2`;
	# `$binpath/bin/usearch -derep_fulllength $_ -output $dupout -sizeout -strand both -minuniquesize 2`;
	if ($Pro eq "y") {
		my $proout="$_".".pro";
		`perl $binpath/bin/Pro_C.pl -lib f -int $Interval -fas $dupout -out $proout`;
		my $otuout="$_".".otu";
		`$binpath/bin/vsearch --cluster_size $proout --sizein --sizeout --id $Ucf --centroids $otuout`;
		# $binpath/bin/usearch -cluster_otus $proout -otu_radius_pct $full_out_pct -otus $otuout
		my $endout="$_".".end";
		open TEI, "$otuout" || die $!;
		open TEO, ">$endout" || die $!;
		$/="\>";<TEI>;$/="\n";
		while(my $ti=<TEI>){
			chomp($ti);
			$/="\>";
			chomp(my $seq = <TEI>);
			$seq=~s/\n//g;
			my @a=split /NNN/,$seq;
			die "the delimiter is wrong, reads can't be seperated into two part" unless (@a == 2);
			my $endlenf=length $a[0];
			my $endlenr=length $a[1];
			if ($endlenf > $Lmk and $endlenr> $Lmk){
				print TEO ">$ti\n$a[0]\n$a[1]\n";
			}
			$/="\n";
		}
		close TEI;
		close TEO;
#		print FEN "$endout\n";
		push @flist,$endout;
		`rm $dupout $proout $otuout`;
	}elsif ($Pro eq "n") {
		my $otuout="$_".".otu";
		`$binpath/bin/vsearch --cluster_size $dupout --sizein --sizeout --id $Ucf --centroids $otuout`;
		# `$binpath/bin/usearch -cluster_otus $dupout -otu_radius_pct $full_out_pct -otus $otuout`;
		my $endout="$_".".end";
		open TEI, "$otuout" || die $!;
		open TEO, ">$endout" || die $!;
		$/="\>";<TEI>;$/="\n";
		while(my $ti=<TEI>){
			chomp($ti);
			$/="\>";
			chomp(my $seq = <TEI>);
			$seq=~s/\n//g;
			my @a=split /NNN/,$seq;
			die "the delimiter is wrong, reads can't be seperated into two part" unless (@a == 2);
			my $endlenf=length $a[0];
			my $endlenr=length $a[1];
			if ($endlenf > $Lmk and $endlenr> $Lmk){
				print TEO ">$ti\n$a[0]\n$a[1]\n";
			}
			$/="\n";
		}
		close TEI;
		close TEO;
#		print FEN "$endout\n";
		push @flist,$endout;
		`rm $dupout $otuout`;
	}else{
		die "-pro parameter should be y or n for protein expression check option\n";
	}
}
close FLI;

########################get full length reads set###########################

#---------------------------------------------------------------#
#---------------------------------------------------------------#

##########################get shotgun reads set##############################
my $Out4="$Out"."."."shotgun";
my ($cmrl,$cmru);
my $expect=2*$lrls-$in_sis;
$cmru=($lrls-1);
if ($expect>=60){$cmrl=int($expect/3)}else{$cmrl=20};
if ($Oop ==1 ){
	`$binpath/bin/cmr -a $Fsfq -b $Bsfq -o $Out4 -2 $Out.1.left -3 $Out.2.left -l $cmrl -u $cmru -c $Osc >overlap.log`;
}elsif ($Oop ==2){
	my $pear_min=$lrls+1;
	my $pear_mio=$cmrl;
	`perl $binpath/bin/pear_overlap.pl -for $Fsfq -rev $Bsfq -out $Out4 -min $pear_min -mio $pear_mio -cpt $Cpt`;
}else{
	die "the overlap program can be setted as 1 for COPE and as 2 for PEAR";
}
print "the shotgun reads have been overlapped";

my $s_out="$Out"."_s";
if ($Mpr ==0){
	`perl $binpath/bin/shotgun_assign.perfect.pl -pri $Primer -fas $Out4 -out $s_out -mis $Mpr -len $Len`;
}else{
	`perl $binpath/bin/shotgun_assign.pl -pri $Primer -fas $Out4 -out $s_out -mis $Mpr -len $Len`;
}
open MLI, "$s_out\_list" || die $!;
my @slist;
my $s_bwa;
#open MDU, ">$mdout" || die $!;
while (<MLI>) {
	chomp;
	my $sortout="$_".".sort";
	if ($Pro eq "y") {
		my $proout="$_".".pro";
		`perl $binpath/bin/Pro_C.pl -lib s -fas $_ -out $proout`;
		`mv $proout $sortout`;
#		`$binpath/bin/usearch -sortbylength $proout -output $sortout`;
#		`rm $proout`;
	}elsif ($Pro eq "n") {
		`mv $_ $sortout`;
#		`$binpath/bin/usearch -sortbylength $_ -output $sortout`;
	}else{
		die "-pro parameter should be y or n for protein expression check option\n";
	}
	my $dupout="$_".".dup";
	`perl $binpath/bin/rmdupctg.pl $sortout $dupout`;
#	print MDU "$dupout\n";
	push @slist, $dupout;
	if ($Len==0){
		$s_bwa = $sortout
	}else{
		`rm $sortout`
	}
}
close MLI;
print "the shotgun reads have been denoised";
 `rm "$s_out\_list" "$f_out\_list"`;
##########################get shotgun reads set##############################

#---------------------------------------------------------------#
#---------------------------------------------------------------#

##########################      asembly        ##############################

my %component;
for my $i (0..$#flist){
	my @a=split /\_|\./,$flist[$i];
	$component{$a[2]}[0]=$flist[$i]; # mgl: 0: *.end files from FLS
}
for my $i (0..$#slist){
	my @a=split /\_|\./,$slist[$i];
	if (exists $component{$a[2]}){
		push @{$component{$a[2]}},$slist[$i]; # mgl: 1: *.dup files from SLS
	}
}

for my $key (keys %component) {
	if (@{$component{$key}}!=2) {
		print "index $key only generate one lib\n";
		next;
	}
	my $libout="$key\.lib";
	open LIB, ">$libout" || die $!;
	print LIB ">\nf=./$component{$key}[1]";
	close LIB;
	print "Let's assemble $key!\n";
	my $assout="$Out\_$key";
	`$binpath/bin/barcode -e $component{$key}[0] -r $libout -l $Lsk -k $Lmk -o $assout -v $Kin -c $Clk -s $Clb -n $Lss -x $Lms -t $Cpt 1>log 2>err`;
	open ASS, "$assout.contig" || die $!;
	open ASF, ">$assout.contig.F" || die $!;
	my %aha;
	$/="\>"; <ASS>; $/="\n";
	while(<ASS>){
        chomp;
        $/="\>";
        chomp(my $seq = <ASS>);
        $/="\n";
        $seq=~s/\n//g;
        my $len=length $seq;
        my @a=split /\t/;
        # >115_1_1        533 # mgl: only choose the first one
        # >115_1_2        815
        # >115_2_1        533
        # >115_3_1        533
        my @b=split /\_/, $a[0];
        $aha{$b[1]}=0 unless(exists $aha{$b[1]});
        if ($b[2]==1){
                $aha{$b[1]}++;
                print ASF ">$_\n$seq\n";
        }elsif($aha{$b[1]}==0){
                $aha{$b[1]}++;
                print ASF ">$_\n$seq\n";
        }else{
                next;
        }
	}
	close ASS;
	close ASF;
#	push @assembled, "$assout.contig.F";
	push @{$component{$key}},"$assout.contig.F"; # mgl: 2: *.contig.F files from barcode program
	`rm $libout`;
}


##########################      asembly        ##############################

#---------------------------------------------------------------#
#---------------------------------------------------------------#

#######   abundance information retrieve and final cluster    #############

print "Let's bwa to obtain the abundance information!\n";

$full_out_pct=(100-$Ucs*100);
my $com_num=keys %component;

for my $key (keys %component){
	next unless (defined $component{$key}[2]);
	if ($com_num==1 && $Len==0){
		print "To obtain the abundance information by mapping SLS reads against assembled sequences\n"; # by mgl.
		`$binpath/bin/bwa index $component{$key}[2]`; # mgl: *.contig.F files
		`$binpath/bin/bwa aln -n 0 -t $Cpt $component{$key}[2] $s_bwa >bwa.sai`; # $s_bwa is *.pro files
		`$binpath/bin/bwa samse $component{$key}[2] bwa.sai $s_bwa >bwa.sam`;
		my $abun_out="$component{$key}[2]"."A";
		`perl $binpath/bin/sam_abundance.pl -fas $component{$key}[2] -sam bwa.sam -out $abun_out`;
		my $sort_out="$abun_out"."S";
		`$binpath/bin/vsearch --sortbysize $abun_out --output $sort_out`;
		#`$binpath/bin/usearch -sortbysize $abun_out -output $sort_out`;
		my $cluster_out="$sort_out"."TA";
		`$binpath/bin/vsearch --cluster_size $sort_out --sizein --sizeout --id $Ucs --centroids $cluster_out`;	
		# `$binpath/bin/usearch -cluster_otus $sort_out -otu_radius_pct $full_out_pct -otus $cluster_out`;
		`rm $abun_out $sort_out`;
	}elsif($com_num >1 && $Len>0){
		print "To obtain the abundance information by extracting abundance from *.end files of FLS data\n"; # by mgl.
		my %chash;
		open CAS, "$component{$key}[2]" || die $!; # mgl: the *.contig.F files from barcode program
		$/="\>";<CAS>;$/="\n";
		while(<CAS>){
			chomp;
			$/="\>";
			chomp(my $seq=<CAS>);
			$/="\n";
			my @a=split /\_/,$_;
			$chash{$a[1]}[0]=$seq;
		}
		close CAS;
		my $cnum=1;
		open CFL, "$component{$key}[0]" || die $!;
		while(<CFL>){
			next unless (/^>/);
			# >TACCT_179;size=1616
			$chash{$cnum}[1]=$_ if (exists $chash{$cnum});
			$cnum++;
		}
		close CFL;
		my $abun_out="$component{$key}[2]"."A";
		open COU, ">$abun_out" || die $!;
		for my $ckey(keys %chash) {
			print COU "$chash{$ckey}[1]\n$chash{$ckey}[0]";
		}
		close COU;
		my $sort_out="$abun_out"."S";
		`$binpath/bin/vsearch --sortbysize $abun_out --output $sort_out`;
		# `$binpath/bin/usearch -sortbysize $abun_out -output $sort_out`;
		my $cluster_out="$sort_out"."TA";
		`$binpath/bin/vsearch --cluster_size $sort_out --sizein --sizeout --id $Ucs --centroids $cluster_out`;
		# `$binpath/bin/vsearch -cluster_otus $sort_out -otu_radius_pct $full_out_pct -otus $cluster_out`;	
#		 `rm $abun_out $sort_out`;
	}else{
		print "there are problems of index length ($Len) and number of assembled reuslts ($com_num)\n";
	}
}

#######   abundance information retrieve and final cluster    #############

print "all done\n";
